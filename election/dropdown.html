<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical PS Selector & Candidate Viewer</title>
    <!-- Include SheetJS library -->
    <script lang="javascript" src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f4f4f4; }
        .container { background: #fff; padding: 20px; border-radius: 8px; max-width: 800px; margin: auto; }
        .loader { margin-bottom: 20px; display: flex; flex-wrap: wrap; /* Allow wrapping */ gap: 10px; align-items: center; }
        #googleSheetUrl { flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px; min-width: 250px; /* Prevent input getting too small */ }
        .button { padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; /* Prevent button text wrap */ }
        .button:disabled { background-color: #ccc; cursor: not-allowed; }
        .button:hover:not(:disabled) { background-color: #0056b3; }
        .dropdown-container { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        label { margin-bottom: 5px; font-weight: bold; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: 100%; }
        select:disabled { background-color: #e9ecef; }
        #status { margin-top: 15px; font-style: italic; color: #555; }
        .hidden { display: none; }

        /* Styles for Candidate Display Area */
        #candidateDisplay {
            margin-top: 30px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
            overflow: scroll;
        }
        #candidateDisplay h2 {
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            font-size: 1.2em;
        }
        .candidate-columns {
            display: flex;
            gap: 20px;
            justify-content: space-around; /* Distribute columns */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .candidate-column {
            flex: 1; /* Allow columns to grow equally */
            min-width: 150px; /* Prevent columns from becoming too narrow */
            margin-bottom: 15px; /* Add space when columns wrap */
        }
        .candidate-column h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1em;
            color: #333;
        }
        .candidate-list {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.9em;
        }
        .candidate-list li {
            padding: 4px 0;
            border-bottom: 1px dashed #eee;
        }
        .candidate-list li:last-child {
            border-bottom: none;
        }
        .candidate-list .uncontested {
            font-style: italic;
            color: #888;
        }
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 50px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        .top-bar h1 {
            margin: 0;
            margin-bottom: 10px; /* Add space when wrapping */
        }

        .top-bar a .button {
            padding: 8px 16px;
            cursor: pointer;
        }

        @media (max-width: 768px) {
            body{
                padding: 0px;
                margin: 0px;
            }
            .loader { flex-direction: column; align-items: stretch; } /* Stack loader items */
             #googleSheetUrl { width: calc(100% - 18px); } /* Adjust width considering padding/border */
            .button { width: 100%; } /* Make buttons full width */
            .top-bar { justify-content: center; text-align: center; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-bar">
            <h1>Polling Station Selector</h1>
            <a href="/election/"><button class="button">Switch to Ballot View</button></a>
        </div>

        <div class="loader">
            <input type="text" id="googleSheetUrl" placeholder="Paste Google Sheet 'Publish to web' CSV Link...">
            <button id="loadFromUrlButton" class="button">Load from URL</button>
            <button id="loadLocalCsvButton" class="button">Load Local CSV</button> <!-- Added Button -->
        </div>
        <!-- Updated Status Message -->
        <div id="status">Enter a Google Sheet URL and click 'Load from URL', or click 'Load Local CSV' to load '24 april data.csv'.</div>

        <div class="dropdown-container">
            <div>
                <label for="zpcSelect">ZPC Name:</label>
                <select id="zpcSelect" disabled>
                    <option value="">-- Select ZPC --</option>
                </select>
            </div>
            <div>
                <label for="apSelect">AP Name:</label>
                <select id="apSelect" disabled>
                    <option value="">-- Select AP --</option>
                </select>
            </div>
            <div>
                <label for="gpSelect">GP Name:</label>
                <select id="gpSelect" disabled>
                    <option value="">-- Select GP --</option>
                </select>
            </div>
            <div>
                <label for="wardSelect">Ward Name:</label>
                <select id="wardSelect" disabled>
                    <option value="">-- Select Ward --</option>
                </select>
            </div>
            <div>
                <label for="psSelect">PS Name:</label>
                <select id="psSelect" disabled>
                    <option value="">-- Select PS --</option>
                </select>
            </div>
        </div>

        <!-- Candidate Display Area (Initially Hidden) -->
        <div id="candidateDisplay" class="hidden">
             <h2>Candidates for Selected PS</h2>
             <div class="candidate-columns">
                 <div class="candidate-column">
                     <h3>Ward Candidates</h3>
                     <ul id="wardCandidateList" class="candidate-list"></ul>
                 </div>
                 <div class="candidate-column">
                    <h3>AP Candidates</h3>
                    <ul id="apCandidateList" class="candidate-list"></ul>
                </div>
                <div class="candidate-column">
                    <h3>ZPC Candidates</h3>
                    <ul id="zpcCandidateList" class="candidate-list"></ul>
                </div>
            </div>
        </div>
        <!-- End Candidate Display Area -->

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const urlInput = document.getElementById('googleSheetUrl');
            const loadUrlButton = document.getElementById('loadFromUrlButton');
            const loadLocalButton = document.getElementById('loadLocalCsvButton'); // New button element
            const statusLabel = document.getElementById('status');
            const zpcSelect = document.getElementById('zpcSelect');
            const apSelect = document.getElementById('apSelect');
            const gpSelect = document.getElementById('gpSelect');
            const wardSelect = document.getElementById('wardSelect');
            const psSelect = document.getElementById('psSelect');

            // Candidate Display Elements
            const candidateDisplayDiv = document.getElementById('candidateDisplay');
            const zpcCandidateList = document.getElementById('zpcCandidateList');
            const apCandidateList = document.getElementById('apCandidateList');
            const wardCandidateList = document.getElementById('wardCandidateList');

            // --- Global State ---
            let rawData = [];
            let hierarchy = new Map(); // Map<zpc, Map<ap, Map<gp, Map<ward, Set<ps>>>>>
            let psCandidateData = new Map(); // Map<formattedPsName, {zpc: [], ap: [], ward: []}>
            let headerMap = {}; // To store actual header names found

            // --- Constants ---
            const LOCAL_CSV_FILENAME = '24 april data.csv'; // Define local filename
            const ZPC_KEY = 'zpc name';
            const AP_KEY = 'ap name';
            const GP_KEY = 'gp name';
            const WARD_KEY = 'ward name';
            const PS_KEY = 'ps name';
            const ZPC_NO_KEY = 'zpc no.';
            const AP_NO_KEY = 'ap no.';
            const GP_NO_KEY = 'gp no.';
            const WARD_NO_KEY = 'ward no.';
            const PS_NO_KEY = 'ps no.';
            // Add candidate prefixes (ensure these match your sheet headers *start*)
            const ZPC_CANDIDATE_PREFIX = 'ZPM';
            const AP_CANDIDATE_PREFIX = 'APM';
            const WARD_CANDIDATE_PREFIX = 'GPM';

            const REQ_KEYS = [
                ZPC_KEY, AP_KEY, GP_KEY, WARD_KEY, PS_KEY,
                ZPC_NO_KEY, AP_NO_KEY, GP_NO_KEY, WARD_NO_KEY, PS_NO_KEY
            ];
            // Note: Candidate columns are not strictly required for the dropdowns,
            // but are required for the candidate display feature. Add checks if needed.

            // --- Event Listeners ---
            loadUrlButton.addEventListener('click', handleUrlLoad);
            loadLocalButton.addEventListener('click', handleLocalCsvLoad); // Listener for the new button
            zpcSelect.addEventListener('change', handleZpcChange);
            apSelect.addEventListener('change', handleApChange);
            gpSelect.addEventListener('change', handleGpChange);
            wardSelect.addEventListener('change', handleWardChange);
            psSelect.addEventListener('change', handlePsSelectChange); // Listener for the final PS dropdown

            // --- Utility Functions ---
            function findHeaderKey(headers, targetKey) {
                const lowerTarget = targetKey.toLowerCase().trim();
                for (const header of headers) {
                    if (String(header).toLowerCase().trim() === lowerTarget) {
                        return header; // Return the exact header name found
                    }
                }
                return null; // Not found
            }

            function populateDropdown(selectElement, options, placeholder) {
                selectElement.innerHTML = `<option value="">-- ${placeholder} --</option>`; // Clear existing options
                options.sort((a, b) => a.localeCompare(b)); // Sort options alphabetically
                options.forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option;
                    selectElement.appendChild(opt);
                });
                selectElement.disabled = options.length === 0; // Disable if no options
            }

            function resetDropdown(selectElement, placeholder) {
                 selectElement.innerHTML = `<option value="">-- ${placeholder} --</option>`;
                 selectElement.disabled = true;
                 selectElement.value = ""; // Reset selection
            }

            function resetAllDropdowns() {
                resetDropdown(zpcSelect, 'Select ZPC');
                resetDropdown(apSelect, 'Select AP');
                resetDropdown(gpSelect, 'Select GP');
                resetDropdown(wardSelect, 'Select Ward');
                resetDropdown(psSelect, 'Select PS');
                clearAndHideCandidates(); // Also reset candidate display
            }

             function setLoadingState(loading) {
                // Disable/enable both buttons and the input
                loadUrlButton.disabled = loading;
                loadLocalButton.disabled = loading;
                urlInput.disabled = loading;
                if (loading) {
                    statusLabel.textContent = 'Loading data...';
                    resetAllDropdowns(); // Disable dropdowns and clear candidates while loading
                } else {
                    // Status will be updated on success/error by the calling function
                }
             }

            // --- Candidate Helper Functions ---
            // Copied from script.js - No changes needed here
            function getCandidateNamesJS(row, prefix) {
                const candidates = [];
                if (!row) return candidates;
                const matchingHeaders = Object.keys(row).filter(key =>
                    typeof key === 'string' && key.trim().toLowerCase().startsWith(prefix.toLowerCase())
                );
                matchingHeaders.sort(); // Simple sort

                for (const key of matchingHeaders) {
                    let value = row[key];
                    if (value !== null && value !== undefined) {
                        const strValue = String(value).trim();
                        if (strValue && strValue.toLowerCase() !== 'nil') {
                            candidates.push(strValue);
                        }
                    }
                }
                return candidates;
            }

            // Helper to format No - Name, handling missing parts - No changes needed here
            function formatNoName(no, name) {
                const numStr = String(no || '').trim();
                const nameStr = String(name || '').trim();

                if (numStr && nameStr) {
                    return `${numStr} - ${nameStr}`;
                } else if (nameStr) {
                    return nameStr;
                } else if (numStr) {
                    return numStr;
                } else {
                    return '';
                }
            }

            // --- Core Logic Functions ---

            // Generic function to process fetched CSV text
            function processCsvData(csvText, sourceDescription) {
                if (!csvText) {
                     throw new Error(`Fetched data (${sourceDescription}) is empty.`);
                }

                // Parse CSV using SheetJS
                const workbook = XLSX.read(csvText, { type: 'string', raw: true });
                const sheetName = workbook.SheetNames[0];
                if (!sheetName) throw new Error(`Could not parse CSV data (${sourceDescription}).`);

                rawData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { defval: null }); // Use null for empty values
                 if (!rawData.length) throw new Error(`CSV data is empty after parsing (${sourceDescription}).`);

                // Find actual header keys (case-insensitive)
                const headers = Object.keys(rawData[0] || {});
                let missingKeys = [];
                headerMap = {}; // Reset header map before finding new ones
                REQ_KEYS.forEach(key => {
                    const foundKey = findHeaderKey(headers, key);
                    if (foundKey) {
                        headerMap[key] = foundKey;
                    } else {
                        missingKeys.push(key.toUpperCase());
                    }
                });

                if (missingKeys.length > 0) {
                    throw new Error(`Required columns not found in ${sourceDescription}: ${missingKeys.join(', ')}`);
                }

                // Process data into hierarchy AND extract candidate data
                processData(); // Re-uses the existing processing logic

                // Populate the first dropdown
                populateZpcDropdown();
                statusLabel.textContent = `Loaded ${rawData.length} rows from ${sourceDescription}. Select ZPC to begin.`;
            }


            async function handleUrlLoad() {
                const url = urlInput.value.trim();
                if (!url) {
                    alert("Please paste a Google Sheet 'Publish to web' CSV URL first.");
                    return;
                }
                 if (!url.includes('/pub?') || !url.includes('output=csv')) {
                     console.warn("URL format might be incorrect. Expected a Google Sheet 'Publish to web' CSV link. Attempting to load anyway...");
                     // Optionally show a less severe warning to the user
                     // statusLabel.textContent = "Warning: URL format might be incorrect. Trying to load...";
                 }

                setLoadingState(true);
                hierarchy.clear(); // Clear previous hierarchy
                psCandidateData.clear(); // Clear previous candidate data
                headerMap = {}; // Clear previous headers

                try {
                    console.log("Fetching URL:", url);
                    const response = await fetch(url, { cache: 'no-store' }); // Use no-store to prevent caching issues

                    if (!response.ok) {
                        throw new Error(`Failed to fetch URL. Status: ${response.status} ${response.statusText}. Check URL & permissions.`);
                    }
                    const csvText = await response.text();
                    processCsvData(csvText, "Google Sheet URL"); // Use the generic processor

                } catch (error) {
                     console.error("URL Loading error:", error);
                     statusLabel.textContent = `Error: ${error.message}`;
                     alert(`URL Loading Error:\n${error.message}`);
                     resetAllDropdowns(); // Reset on error
                } finally {
                    setLoadingState(false);
                }
            }

            // New Handler for loading local CSV
            async function handleLocalCsvLoad() {
                setLoadingState(true);
                hierarchy.clear(); // Clear previous data
                psCandidateData.clear();
                headerMap = {};

                try {
                    console.log("Fetching local file:", LOCAL_CSV_FILENAME);
                    // Fetch the local file. IMPORTANT: This requires the HTML file to be served
                    // by a web server (even a simple local one like Python's http.server or VS Code Live Server).
                    // It will likely fail if you open the HTML directly from the filesystem (file:///).
                    const response = await fetch(LOCAL_CSV_FILENAME, { cache: 'no-store' });

                    if (!response.ok) {
                        // Provide a more helpful error message for common local file issues
                        if (response.status === 404) {
                             throw new Error(`Failed to fetch local file '${LOCAL_CSV_FILENAME}'. Status: ${response.status} ${response.statusText}. Make sure the file exists in the same directory as the HTML file and that you are running this page from a web server (not file:/// protocol).`);
                        } else {
                            throw new Error(`Failed to fetch local file '${LOCAL_CSV_FILENAME}'. Status: ${response.status} ${response.statusText}.`);
                        }
                    }
                    const csvText = await response.text();
                    processCsvData(csvText, `local file '${LOCAL_CSV_FILENAME}'`); // Use the generic processor

                } catch (error) {
                     console.error("Local CSV Loading error:", error);
                     statusLabel.textContent = `Error: ${error.message}`;
                     // Use alert for more prominent error display, especially for local file issues
                     alert(`Local CSV Loading Error:\n${error.message}`);
                     resetAllDropdowns(); // Reset on error
                } finally {
                    setLoadingState(false);
                }
            }


             function processData() {
                 hierarchy.clear(); // Ensure it's empty before processing
                 psCandidateData.clear(); // Clear candidate data map too

                 const processedPsNames = new Set(); // To handle potential duplicates if hierarchy levels are identical but candidates differ

                 rawData.forEach((row, index) => { // Added index for logging
                     // Check if row is an object, skip if not (e.g., empty rows parsed weirdly)
                     if (typeof row !== 'object' || row === null) {
                         // console.warn(`Skipping invalid row data at index ${index}:`, row);
                         return;
                     }
                     // Get hierarchy keys using the mapped header names
                     const zpcName = formatNoName(row[headerMap[ZPC_NO_KEY]], row[headerMap[ZPC_KEY]]);
                     const apName = formatNoName(row[headerMap[AP_NO_KEY]], row[headerMap[AP_KEY]]);
                     const gpName = formatNoName(row[headerMap[GP_NO_KEY]], row[headerMap[GP_KEY]]);
                     const wardName = formatNoName(row[headerMap[WARD_NO_KEY]], row[headerMap[WARD_KEY]]);
                     const psName = formatNoName(row[headerMap[PS_NO_KEY]], row[headerMap[PS_KEY]]);

                     // Build Hierarchy (only if all levels have names)
                     if (zpcName && apName && gpName && wardName && psName) {
                         if (!hierarchy.has(zpcName)) hierarchy.set(zpcName, new Map());
                         const zpcMap = hierarchy.get(zpcName);

                         if (!zpcMap.has(apName)) zpcMap.set(apName, new Map());
                         const apMap = zpcMap.get(apName);

                         if (!apMap.has(gpName)) apMap.set(gpName, new Map());
                         const gpMap = apMap.get(gpName);

                         if (!gpMap.has(wardName)) gpMap.set(wardName, new Set());
                         const wardSet = gpMap.get(wardName);

                         wardSet.add(psName);

                         // Store Candidate Data (using the formatted psName as the key)
                         // Only store the first occurrence for a given PS name to avoid overwriting
                         // if the same PS name appears multiple times (e.g., due to data entry issues)
                         if (!processedPsNames.has(psName)) {
                             const candidates = {
                                 zpc: getCandidateNamesJS(row, ZPC_CANDIDATE_PREFIX),
                                 ap: getCandidateNamesJS(row, AP_CANDIDATE_PREFIX),
                                 ward: getCandidateNamesJS(row, WARD_CANDIDATE_PREFIX)
                             };
                             psCandidateData.set(psName, candidates);
                             processedPsNames.add(psName);
                             // console.log(`Stored candidates for PS: ${psName}`, candidates); // Uncomment for debugging
                         }
                     } else {
                        // Optionally log skipped rows
                         // console.warn(`Skipping row at index ${index} due to missing hierarchy name(s):`, {zpcName, apName, gpName, wardName, psName}, "Raw Row:", row);
                     }
                 });
                 // console.log("Hierarchy built:", hierarchy); // For debugging
                 // console.log("Candidate data mapped:", psCandidateData); // For debugging
                 if (hierarchy.size === 0) {
                     console.warn("Hierarchy map is empty after processing. Check data format and required columns.");
                     statusLabel.textContent += " Warning: No valid hierarchy data found. Check CSV format/content.";
                 }
             }

            // --- Dropdown Population and Handling ---
            // No changes needed in these handlers (handleZpcChange, handleApChange, etc.)

            function populateZpcDropdown() {
                const zpcNames = Array.from(hierarchy.keys());
                populateDropdown(zpcSelect, zpcNames, 'Select ZPC');
                resetDropdown(apSelect, 'Select AP');
                resetDropdown(gpSelect, 'Select GP');
                resetDropdown(wardSelect, 'Select Ward');
                resetDropdown(psSelect, 'Select PS'); // This calls clearAndHideCandidates implicitly
            }

            function handleZpcChange() {
                const selectedZpc = zpcSelect.value;
                resetDropdown(apSelect, 'Select AP');
                resetDropdown(gpSelect, 'Select GP');
                resetDropdown(wardSelect, 'Select Ward');
                resetDropdown(psSelect, 'Select PS'); // Clears subsequent dropdowns and candidates

                if (selectedZpc && hierarchy.has(selectedZpc)) {
                    const apMap = hierarchy.get(selectedZpc);
                    const apNames = Array.from(apMap.keys());
                    populateDropdown(apSelect, apNames, 'Select AP');
                }
            }

             function handleApChange() {
                 const selectedZpc = zpcSelect.value;
                 const selectedAp = apSelect.value;
                 resetDropdown(gpSelect, 'Select GP');
                 resetDropdown(wardSelect, 'Select Ward');
                 resetDropdown(psSelect, 'Select PS'); // Clears subsequent dropdowns and candidates

                 if (selectedZpc && selectedAp && hierarchy.has(selectedZpc) && hierarchy.get(selectedZpc).has(selectedAp)) {
                     const gpMap = hierarchy.get(selectedZpc).get(selectedAp);
                     const gpNames = Array.from(gpMap.keys());
                     populateDropdown(gpSelect, gpNames, 'Select GP');
                 }
             }

              function handleGpChange() {
                 const selectedZpc = zpcSelect.value;
                 const selectedAp = apSelect.value;
                 const selectedGp = gpSelect.value;
                 resetDropdown(wardSelect, 'Select Ward');
                 resetDropdown(psSelect, 'Select PS'); // Clears subsequent dropdowns and candidates

                  if (selectedZpc && selectedAp && selectedGp &&
                      hierarchy.has(selectedZpc) &&
                      hierarchy.get(selectedZpc).has(selectedAp) &&
                      hierarchy.get(selectedZpc).get(selectedAp).has(selectedGp)) {
                     const wardMap = hierarchy.get(selectedZpc).get(selectedAp).get(selectedGp);
                     const wardNames = Array.from(wardMap.keys());
                     populateDropdown(wardSelect, wardNames, 'Select Ward');
                 }
             }

             function handleWardChange() {
                 const selectedZpc = zpcSelect.value;
                 const selectedAp = apSelect.value;
                 const selectedGp = gpSelect.value;
                 const selectedWard = wardSelect.value;
                 resetDropdown(psSelect, 'Select PS'); // Clears subsequent dropdowns and candidates

                 if (selectedZpc && selectedAp && selectedGp && selectedWard &&
                     hierarchy.has(selectedZpc) &&
                     hierarchy.get(selectedZpc).has(selectedAp) &&
                     hierarchy.get(selectedZpc).get(selectedAp).has(selectedGp) &&
                     hierarchy.get(selectedZpc).get(selectedAp).get(selectedGp).has(selectedWard)) {
                    const psSet = hierarchy.get(selectedZpc).get(selectedAp).get(selectedGp).get(selectedWard);
                    const psNames = Array.from(psSet);
                    populateDropdown(psSelect, psNames, 'Select PS');
                 }
             }

             // --- Candidate Display Logic ---
             // No changes needed here (handlePsSelectChange, displayCandidates, clearAndHideCandidates)

             function handlePsSelectChange() {
                 const selectedPs = psSelect.value;
                 if (selectedPs && psCandidateData.has(selectedPs)) {
                     const candidates = psCandidateData.get(selectedPs);
                     displayCandidates(candidates);
                 } else {
                     clearAndHideCandidates();
                 }
             }

             function displayCandidates(candidates) {
                 if (!candidates) {
                    clearAndHideCandidates();
                    return;
                 }
                 // Helper to populate a single list
                 const populateList = (listElement, candidateArray) => {
                     listElement.innerHTML = ''; // Clear previous items
                     if (candidateArray && candidateArray.length > 0) {
                         candidateArray.forEach(name => {
                             const li = document.createElement('li');
                             li.textContent = name;
                             listElement.appendChild(li);
                         });
                     } else {
                         const li = document.createElement('li');
                         li.textContent = 'Uncontested or Nil';
                         li.classList.add('uncontested');
                         listElement.appendChild(li);
                     }
                 };

                 populateList(zpcCandidateList, candidates.zpc);
                 populateList(apCandidateList, candidates.ap);
                 populateList(wardCandidateList, candidates.ward);

                 candidateDisplayDiv.classList.remove('hidden'); // Show the display area
             }

             function clearAndHideCandidates() {
                 zpcCandidateList.innerHTML = '';
                 apCandidateList.innerHTML = '';
                 wardCandidateList.innerHTML = '';
                 candidateDisplayDiv.classList.add('hidden'); // Hide the display area
             }

            // --- Initial State ---
            resetAllDropdowns(); // Includes clearing/hiding candidates

        }); // End DOMContentLoaded
    </script>
</body>
</html>